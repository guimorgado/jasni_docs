---
title: "Security"
description: "How to verify webhook signatures and secure your endpoints"
icon: "/icons-svg/keys.svg"
---

## Why Verify Signatures?

When you receive a webhook, you need to verify it actually came from Jasni and hasn't been tampered with. Without verification, attackers could:

- Send fake events to your endpoint
- Modify legitimate payloads in transit
- Trigger unintended actions in your system

## Signature Verification

Every webhook request includes a signature in the `X-Jasni-Signature` header. This signature follows the format `t=timestamp,v1=signature` where:

- `t` is the Unix timestamp when the webhook was sent
- `v1` is the HMAC-SHA256 signature

### How It Works

```
SignedPayload = timestamp + "." + request_body
Signature = HMAC-SHA256(SignedPayload, webhook_secret)
Header = "t=" + timestamp + ",v1=" + Signature
```

1. Jasni creates the request body (JSON payload)
2. Prepends the timestamp to the payload: `timestamp.payload`
3. Computes HMAC-SHA256 of the combined string using your webhook secret
4. Includes the signature in the `X-Jasni-Signature` header as `t=timestamp,v1=signature`
5. Sends the request to your endpoint

### Verification Steps

1. Parse the `X-Jasni-Signature` header to extract `t` (timestamp) and `v1` (signature)
2. Check if the timestamp is within tolerance (e.g., 5 minutes) to prevent replay attacks
3. Reconstruct the signed payload: `timestamp.raw_body`
4. Compute your own HMAC-SHA256 of the signed payload
5. Compare signatures using a timing-safe function
6. Reject if they don't match

## Implementation

The Jasni SDKs provide built-in signature verification helpers that handle all the complexity for you:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    import { verifySignature, constructEvent } from 'jasni-sdk'
    import express from 'express'

    const app = express()

    // Option 1: Using verifySignature
    app.post('/webhooks/jasni', express.raw({ type: 'application/json' }), (req, res) => {
      const signature = req.headers['x-jasni-signature'] as string
      const payload = req.body.toString()
      
      if (!verifySignature(payload, signature, process.env.WEBHOOK_SECRET!)) {
        return res.status(401).send('Invalid signature')
      }
      
      const event = JSON.parse(payload)
      console.log('Verified event:', event.event)
      
      res.status(200).send('OK')
    })

    // Option 2: Using constructEvent (verifies and parses in one step)
    app.post('/webhooks/jasni', express.raw({ type: 'application/json' }), (req, res) => {
      try {
        const event = constructEvent(
          req.body,
          req.headers['x-jasni-signature'] as string,
          process.env.WEBHOOK_SECRET!
        )
        
        console.log('Verified event:', event.event)
        res.status(200).send('OK')
      } catch (err) {
        return res.status(401).send('Invalid signature')
      }
    })
    ```
  </Tab>
  
  <Tab title="Python (Flask)">
    ```python
    from flask import Flask, request, jsonify
    from jasni.webhooks import verify_signature
    import os

    app = Flask(__name__)
    WEBHOOK_SECRET = os.environ.get('WEBHOOK_SECRET')

    @app.route('/webhooks/jasni', methods=['POST'])
    def handle_webhook():
        signature = request.headers.get('X-Jasni-Signature')
        payload = request.get_data()  # Use raw body
        
        if not verify_signature(payload, signature, WEBHOOK_SECRET):
            return jsonify({'error': 'Invalid signature'}), 401
        
        event = request.get_json()
        print(f"Verified event: {event['event']}")
        
        return 'OK', 200
    ```
  </Tab>
  
  <Tab title="Python (FastAPI)">
    ```python
    from fastapi import FastAPI, Request, HTTPException
    from jasni.webhooks import verify_signature
    import os

    app = FastAPI()
    WEBHOOK_SECRET = os.environ.get('WEBHOOK_SECRET')

    @app.post("/webhooks/jasni")
    async def handle_webhook(request: Request):
        signature = request.headers.get("X-Jasni-Signature")
        payload = await request.body()  # Use raw body
        
        if not verify_signature(payload, signature, WEBHOOK_SECRET):
            raise HTTPException(status_code=401, detail="Invalid signature")
        
        event = await request.json()
        print(f"Verified event: {event['event']}")
        
        return {"status": "ok"}
    ```
  </Tab>
</Tabs>

<Tip>
  The `verifySignature()` helper automatically handles timestamp validation (5-minute tolerance) and uses timing-safe comparison to prevent timing attacks.
</Tip>

## Important Considerations

### Use Raw Body

<Warning>
  You must use the **raw request body** for signature verification, not a parsed/serialized version. JSON parsing and re-serialization can change whitespace, key order, etc.
</Warning>

<Tabs>
  <Tab title="TypeScript">
```typescript
// ❌ WRONG - body has been parsed and re-serialized
const payload = JSON.stringify(req.body)

// ✅ CORRECT - use raw body with express.raw()
app.post('/webhooks/jasni', express.raw({ type: 'application/json' }), (req, res) => {
  const payload = req.body.toString()
  // ...
})
```
  </Tab>
  <Tab title="Python">
```python
# ❌ WRONG - body has been parsed
payload = json.dumps(request.json)

# ✅ CORRECT - use raw body
payload = request.get_data()  # Flask
payload = await request.body()  # FastAPI
```
  </Tab>
</Tabs>

### What the SDK Handles Automatically

The `verifySignature()` helper handles these security concerns for you:

- **Timing-safe comparison** - Prevents timing attacks by using constant-time comparison
- **Timestamp validation** - Rejects requests older than 5 minutes to prevent replay attacks
- **Signature parsing** - Correctly parses the `t=timestamp,v1=signature` format

## Protecting Your Secret

<AccordionGroup>
  <Accordion title="Store securely" icon="/icons-svg/keys.svg">
    Never hardcode the secret in your code. Use environment variables or a secrets manager.
    
    ```bash
    export WEBHOOK_SECRET="whsec_abc123..."
    ```
  </Accordion>
  
  <Accordion title="Rotate if compromised" icon="/icons-svg/refresh.svg">
    If you suspect the secret is compromised:
    1. Delete the webhook
    2. Create a new webhook (gets new secret)
    3. Update your server with the new secret
  </Accordion>
  
  <Accordion title="Use HTTPS" icon="/icons-svg/world.svg">
    Always use HTTPS for your webhook endpoint. This encrypts the payload in transit.
  </Accordion>
  
  <Accordion title="Restrict access" icon="/icons-svg/alert.svg">
    - Whitelist Jasni's IP addresses if possible
    - Use a unique, random URL path
    - Consider additional authentication headers
  </Accordion>
</AccordionGroup>

## Testing Your Integration

The easiest way to test your webhook integration is to:

1. **Create a test webhook** pointing to your local endpoint (use [ngrok](https://ngrok.com) for local development)
2. **Trigger a real event** by sending an email to your Jasni account
3. **Check your logs** to verify the webhook was received and verified

<Tabs>
  <Tab title="TypeScript">
```typescript
import { verifySignature } from 'jasni-sdk'

// In your tests, you can verify that your endpoint correctly validates signatures
const isValid = verifySignature(
  testPayload,
  testSignature,
  process.env.WEBHOOK_SECRET!
)

console.log('Signature valid:', isValid)
```
  </Tab>
  <Tab title="Python">
```python
from jasni.webhooks import verify_signature

# In your tests, you can verify that your endpoint correctly validates signatures
is_valid = verify_signature(
    test_payload,
    test_signature,
    os.environ.get('WEBHOOK_SECRET')
)

print(f"Signature valid: {is_valid}")
```
  </Tab>
</Tabs>
