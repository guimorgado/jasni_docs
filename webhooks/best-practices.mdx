---
title: "Setup Guide"
description: "Step-by-step guide to configure and test your webhook integrations"
icon: "/icons-svg/check.svg"
---

## Prerequisites

Before setting up webhooks, make sure you have:

<Check>A Jasni API key (go to **Developers** â†’ **API Keys** in your [dashboard](https://app.jasni.ai))</Check>
<Check>A publicly accessible HTTPS endpoint</Check>
<Check>A way to store secrets securely (environment variables, secrets manager)</Check>

---

## Step 1: Create Your Endpoint

Create an HTTP POST endpoint to receive webhook events:

<Tabs>
  <Tab title="TypeScript (Express)">
```typescript
import { verifySignature } from 'jasni-sdk'
import express from 'express'

const app = express()

app.post('/webhooks/jasni', express.raw({ type: 'application/json' }), (req, res) => {
  const signature = req.headers['x-jasni-signature'] as string
  const payload = req.body.toString()
  
  if (!verifySignature(payload, signature, process.env.WEBHOOK_SECRET!)) {
    return res.status(401).send('Invalid signature')
  }
  
  // Acknowledge immediately
  res.status(200).send('OK')
  
  // Process async
  const event = JSON.parse(payload)
  handleEvent(event)
})

app.listen(3000)
```
  </Tab>
  
  <Tab title="Python (FastAPI)">
```python
from fastapi import FastAPI, Request, HTTPException
from jasni.webhooks import verify_signature
import os

app = FastAPI()

@app.post("/webhooks/jasni")
async def handle_webhook(request: Request):
    signature = request.headers.get("X-Jasni-Signature")
    payload = await request.body()
    
    if not verify_signature(payload, signature, os.environ.get("WEBHOOK_SECRET")):
        raise HTTPException(status_code=401, detail="Invalid signature")
    
    event = await request.json()
    await handle_event(event)
    
    return {"status": "ok"}
```
  </Tab>
  
  <Tab title="Next.js">
```typescript
// app/api/webhooks/jasni/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { verifySignature } from 'jasni-sdk'

export async function POST(request: NextRequest) {
  const signature = request.headers.get('x-jasni-signature')!
  const payload = await request.text()
  
  if (!verifySignature(payload, signature, process.env.WEBHOOK_SECRET!)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 })
  }
  
  const event = JSON.parse(payload)
  await handleEvent(event)
  
  return NextResponse.json({ received: true })
}
```
  </Tab>
</Tabs>

---

## Step 2: Register Your Webhook

<Tabs>
  <Tab title="TypeScript">
```typescript
import { Jasni } from 'jasni-sdk'

const jasni = new Jasni('jsk_your_api_key')

const { webhook } = await jasni.webhooks.create({
  url: 'https://your-server.com/webhooks/jasni',
  events: ['email.received', 'email.sent'],
  description: 'Production webhook',
})

// IMPORTANT: Save this secret!
console.log('Webhook Secret:', webhook.secret)
```
  </Tab>
  
  <Tab title="Python">
```python
from jasni import Jasni

jasni = Jasni("jsk_your_api_key")

result = jasni.webhooks.create(
    url="https://your-server.com/webhooks/jasni",
    events=["email.received", "email.sent"],
    description="Production webhook"
)

# IMPORTANT: Save this secret!
print(f"Webhook Secret: {result.webhook.secret}")
```
  </Tab>
</Tabs>

<Warning>
  **Save the secret immediately!** The webhook secret is only shown once when creating the webhook. Store it securely in your environment variables.
</Warning>

---

## Step 3: Signature Verification

The SDK provides `verifySignature()` which handles all the security concerns automatically:

- Parses the signature header format (`t=timestamp,v1=signature`)
- Validates timestamp to prevent replay attacks (5-minute tolerance)
- Uses timing-safe comparison to prevent timing attacks

<Tabs>
  <Tab title="TypeScript">
```typescript
import { verifySignature } from 'jasni-sdk'

// Returns true if signature is valid
const isValid = verifySignature(
  payload,           // Raw request body as string
  signature,         // X-Jasni-Signature header
  webhookSecret      // Your webhook secret
)
```
  </Tab>
  
  <Tab title="Python">
```python
from jasni.webhooks import verify_signature

# Returns True if signature is valid
is_valid = verify_signature(
    payload,           # Raw request body as bytes
    signature,         # X-Jasni-Signature header
    webhook_secret     # Your webhook secret
)
```
  </Tab>
</Tabs>

<Tip>
  See the [Security guide](/webhooks/security) for more details on how signature verification works.
</Tip>

---

## Step 4: Handle Events

Implement handlers for each event type you've subscribed to:

<Tabs>
  <Tab title="TypeScript">
```typescript
async function handleEvent(event: WebhookEvent) {
  switch (event.event) {
    case 'email.received':
      await processIncomingEmail(event.data)
      break
    case 'email.sent':
      await logSentEmail(event.data)
      break
    case 'email.bounced':
      await handleBounce(event.data)
      break
    case 'email.spam':
      await logSpamEmail(event.data)
      break
    case 'email.deleted':
      await syncDeletion(event.data)
      break
  }
}
```
  </Tab>
  <Tab title="Python">
```python
async def handle_event(event: dict):
    match event["event"]:
        case "email.received":
            await process_incoming_email(event["data"])
        case "email.sent":
            await log_sent_email(event["data"])
        case "email.bounced":
            await handle_bounce(event["data"])
        case "email.spam":
            await log_spam_email(event["data"])
        case "email.deleted":
            await sync_deletion(event["data"])
```
  </Tab>
</Tabs>

---

## Step 5: Test Your Integration

### Local Development with ngrok

Use [ngrok](https://ngrok.com) to expose your local server:

```bash
# Start your local server
npm run dev  # Running on http://localhost:3000

# In another terminal, expose it publicly
ngrok http 3000
```

Use the ngrok URL (e.g., `https://abc123.ngrok.io/webhooks/jasni`) when creating your test webhook.

### Send a Test Event

The easiest way to test is to trigger a real event:

1. Create a webhook pointing to your ngrok URL
2. Send an email to your Jasni account
3. Check your logs for the received webhook

For automated testing, you can use the webhook secret to generate valid test payloads in your test suite.

---

## Best Practices

### Respond Quickly

<Warning>
  Webhook requests timeout after **30 seconds**. Return a `200` response immediately, then process asynchronously.
</Warning>

<Tabs>
  <Tab title="TypeScript">
```typescript
app.post('/webhooks/jasni', express.raw({ type: 'application/json' }), (req, res) => {
  // Acknowledge FIRST
  res.status(200).send('OK')
  
  // Process AFTER responding
  processEventAsync(JSON.parse(req.body.toString())).catch(console.error)
})
```
  </Tab>
  <Tab title="Python">
```python
from fastapi import BackgroundTasks

@app.post("/webhooks/jasni")
async def handle_webhook(request: Request, background_tasks: BackgroundTasks):
    event = await request.json()
    
    # Add to background tasks
    background_tasks.add_task(process_event_async, event)
    
    # Acknowledge immediately
    return {"status": "ok"}
```
  </Tab>
</Tabs>

### Handle Duplicates

The same event might be delivered multiple times. Use idempotency:

<Tabs>
  <Tab title="TypeScript">
```typescript
const processedEvents = new Set() // Use Redis in production

async function handleEvent(event: WebhookEvent) {
  const eventId = `${event.event}-${event.data.id}-${event.timestamp}`
  
  if (processedEvents.has(eventId)) {
    console.log('Duplicate, skipping:', eventId)
    return
  }
  
  processedEvents.add(eventId)
  await processEvent(event)
}
```
  </Tab>
  <Tab title="Python">
```python
processed_events = set()  # Use Redis in production

async def handle_event(event: dict):
    event_id = f"{event['event']}-{event['data']['id']}-{event['timestamp']}"
    
    if event_id in processed_events:
        print(f"Duplicate, skipping: {event_id}")
        return
    
    processed_events.add(event_id)
    await process_event(event)
```
  </Tab>
</Tabs>

### Use a Message Queue

For high-volume webhooks, queue events for processing:

<Tabs>
  <Tab title="TypeScript (BullMQ)">
```typescript
import { Queue, Worker } from 'bullmq'

const webhookQueue = new Queue('webhooks')

// Endpoint adds to queue
app.post('/webhooks/jasni', express.raw({ type: 'application/json' }), async (req, res) => {
  const event = JSON.parse(req.body.toString())
  await webhookQueue.add('process', event)
  res.status(200).send('OK')
})

// Worker processes queue
new Worker('webhooks', async (job) => {
  await processEvent(job.data)
})
```
  </Tab>
  <Tab title="Python (Celery)">
```python
from celery import Celery

celery = Celery('webhooks', broker='redis://localhost:6379')

@celery.task
def process_webhook(event: dict):
    process_event(event)

@app.post("/webhooks/jasni")
async def handle_webhook(request: Request):
    event = await request.json()
    process_webhook.delay(event)
    return {"status": "ok"}
```
  </Tab>
</Tabs>

---

## Deployment Checklist

<Check>**Use HTTPS** - Never use HTTP in production</Check>
<Check>**Verify signatures** - Always validate `X-Jasni-Signature`</Check>
<Check>**Store secrets securely** - Use environment variables or a secrets manager</Check>
<Check>**Handle duplicates** - Implement idempotency</Check>
<Check>**Respond quickly** - Return 200 within 30 seconds</Check>
<Check>**Log events** - Track received webhooks for debugging</Check>
<Check>**Monitor errors** - Set up alerts for failures</Check>
<Check>**Test thoroughly** - Verify all event types work correctly</Check>

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Webhook not receiving events">
    - Verify your endpoint is publicly accessible
    - Check that the webhook is active (`active: true`)
    - Ensure you're subscribed to the correct events
    - Check your server logs for incoming requests
  </Accordion>
  
  <Accordion title="Signature verification failing">
    - Use the **raw request body**, not parsed JSON
    - Ensure you're using the correct webhook secret
    - Check that the secret hasn't been rotated
  </Accordion>
  
  <Accordion title="Events arriving late or duplicated">
    - Jasni retries failed deliveries (10s, 60s, 300s delays)
    - Implement idempotency to handle duplicates
    - Ensure your endpoint responds with 200 quickly
  </Accordion>
  
  <Accordion title="Missing webhook secret">
    - The secret is only shown once at creation
    - Delete the webhook and create a new one
    - Save the new secret immediately
  </Accordion>
</AccordionGroup>

---

## Next Steps

<CardGroup cols={2}>
  <Card title="Events Reference" icon="/icons-svg/bolt.svg" href="/webhooks/events">
    See all event types and payloads
  </Card>
  <Card title="Security" icon="/icons-svg/keys.svg" href="/webhooks/security">
    Learn about signature verification
  </Card>
</CardGroup>
